---
layout: post
title:  "two sum，three sum"
date:   2019-03-09 17:00:00 +0800
categories: leetcode
---
### 我的代码
#### 代码一
```C
int* twoSum(int* nums, int numsSize, int target) {
    int i;
    int j;
    int temp;
    int *values=(int *)malloc(2*sizeof(int));
    for(i=0;i<numsSize;i++){
        temp=nums[i];
        for(j=i;j<numsSize;j++){
            if(target-temp==nums[j]){
                values[0]=i;
                values[1]=j;
            }
        }
    }
    return values;
}
```
##### 测试结果
```
Wrong Answer
Details 
Input
[3,3]
6
Output
[1,1]
Expected
[0,1]
```
##### 分析
j的初始值应当比i大才能获取的是数组中的两个。

#### 代码二
```
int* twoSum(int* nums, int numsSize, int target) {
    int i;
    int j;
    int temp;
    int foundflag=0;
    int *values=(int *)malloc(2*sizeof(int));
    for(i=0;i<numsSize;i++){
        temp=nums[i];
        for(j=i+1;j<numsSize;j++){
            if(target-temp==nums[j]){
                values[0]=i;
                values[1]=j;
                foundflag=1
                break;
            }
        }
        if(floudflag==1){
            break;
        }
    }
    return values;
}
```
##### 测试结果
Details 
Runtime: 128 ms, faster than 42.13% of C online submissions for Two Sum.
Memory Usage: 7.6 MB, less than 65.55% of C online submissions for Two Sum.

### 总结
没有把握好细节部分的处理

### threesum

#### 代码一

```C
int * sort(int *nums,int size){
	int i=0;
	int j=0;
	int tmp;
	int *result=(int*)malloc(size*sizeof(int *));
	for(i=0;i<size;i++){
		result[i]=nums[i];
	}
	for(i=0;i<size-1;i++){
		for(j=0;j<size-i-1;j++){
			if(result[j]>result[j+1]){
                tmp=result[j];
                result[j]=result[j+1];
                result[j+1]=tmp;
			}
		}
	}
	return result;
}
int** threeSum(int* nums, int numsSize, int* returnSize) {
    int i;
    int j;
    int k;
    int l;
    int m;
    int flag=0;
    int search;
    int equal;
    int uniq=0;
	int * in_result,*new_one;
    int **result=(int **)malloc(0);
    for(i=0;i<numsSize;i++){
        for(j=i+1;j<numsSize;j++){
            for(k=j+1;k<numsSize;k++){
                if(nums[i]+nums[j]+nums[k]==0){
                    int *value=(int*)malloc(3*sizeof(int));
                    value[0]=nums[i];
                    value[1]=nums[j];
                    value[2]=nums[k];
                    equal=0;
                    uniq=0;
                    new_one=sort(value,3);
                    for(search=0;search<flag;search++){
						in_result=sort(result[search],3);
                        for(l=0;l<3;l++){
							if(in_result[l]!=new_one[l]){
								break;
							}
                        }
						if(l==3){
							uniq=1;
							break;
						}
                        free(in_result);
                    }
                    if(uniq==1){
                        break;
                    }
                    flag++;
                    result=(int**)realloc(result,flag*sizeof(int*));
                    result[flag-1]=value;
                    free(new_one);
                }
            }

        }
    }
	*returnSize=flag;
    return result;
}
```
#### 测试结果
Time Limit Exceeded

#### 代码二

```c
struct Node{
    int a;
    int b;
    int c;
    struct Node *next;
};
void sort(int *list,int size){
    int i,j,tmp,k;
    for(i=0;i<size-1;i++){
        for(j=0;j<size-i-1;j++){
            if(list[j]>list[j+1]){
                tmp=list[j];
                list[j]=list[j+1];
                list[j+1]=tmp;
            }
        }
    }
}
int** threeSum(int* nums, int numsSize, int* returnSize){
    int i,left,right,sum;
    int **result=NULL;
    struct Node *head=NULL;
    struct Node *curr=NULL;
    struct Node *pre=NULL;
    int *value;
    sort(nums,numsSize);
    for(i=0;i<numsSize-1;i++){
        if(i>0&&nums[i]==nums[i-1]){
            continue;
        }
        left=i+1;
        right=numsSize-1;
        while(left<right){
            sum=nums[i]+nums[left]+nums[right];
            if(sum==0){
                (*returnSize)++;
                if(!head){
                    head=(struct Node*)malloc(sizeof(struct Node));
                    curr=head;
                }else{
                    curr=(struct Node*)malloc(sizeof(struct Node));
                }
                curr->a=nums[i];
                curr->b=nums[left];
                curr->c=nums[right];
                curr->next=NULL;
                if(pre){
                    pre->next=curr;
                }
                pre=curr;

                while(left<right&&nums[left]==nums[left+1]){
                    left++;
                }
                while(left<right&&nums[right]==nums[right-1]){
                    right--;
                }
                left++;
                right--;
            }else if(sum<0){
                left++;
            }else{
                right--;
            }

        }
    }
    result=(int **)malloc((*returnSize)*sizeof(int*));
    i=0;
    while(head){
        value=(int *)malloc(sizeof(int)*3);
        value[0]=head->a;
        value[1]=head->b;
        value[2]=head->c;
        result[i++]=value;
        curr=head;
        head=head->next;
        free(curr);
    }
    return result;
}
```

#### 运行结果

```
Runtime: 168 ms
Memory Usage: 24.5 MB
```



