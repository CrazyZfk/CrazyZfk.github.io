<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | crazyzfk's blog]]></title>
  <link href="http://crazyzfk.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://crazyzfk.github.io/"/>
  <updated>2019-12-15T13:08:07+08:00</updated>
  <id>http://crazyzfk.github.io/</id>
  <author>
    <name><![CDATA[zfk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://crazyzfk.github.io/blog/2019/12/15/longest-palindromic-substring/"/>
    <updated>2019-12-15T12:50:37+08:00</updated>
    <id>http://crazyzfk.github.io/blog/2019/12/15/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>找出字符串s中最长的回文子串，假设s最长为1000.</p>

<p>例子1：</p>

<pre><code class="c">Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
</code></pre>

<p>例子2:</p>

<pre><code class="c">Input: "cbbd"
Output: "bb"
</code></pre>

<h2>问题分析</h2>

<ol>
<li>首先需要找到字符串中的所有回文子串。</li>
<li>选择上一步中所有回文子串中最长的。</li>
</ol>


<h3>查找回文子串</h3>

<p>回文字符串的最大特点是整个字符串是对称的结构，可以使用两个指针来分别代表子串的开始和结束。然后在确定子串是否是对称的，由此来判断字符串是否是回文的。</p>

<p>下面的代码是打印所有的回文子串并返回最长子串的长度：</p>

<pre><code class="c">int findPalindromicString(char *s){
    char *sp=s,*ep=s+1;
    char *tmpSp,*tmpEp;
    bool isPalindromic=true;
    int result =0;
    int tmpResult =0;
    while (*sp)
    {
        while(*ep){
            for(tmpSp=sp,tmpEp=ep;tmpSp&lt;tmpEp;tmpSp++,tmpEp--){
                if(*tmpSp != *tmpEp){
                    isPalindromic = false;
                    break;
                }
            }
            if(isPalindromic){
                for(tmpSp = sp;tmpSp&lt;=ep;tmpSp++){
                    tmpResult++;
                    printf("%c",*tmpSp);
                }
                printf("\n");
                if(tmpResult &gt; result){
                    result = tmpResult;
                }
            }
            isPalindromic = true;
            ep++;
        }
        sp++;
        ep = sp + 1;
        isPalindromic = true;
        tmpResult = 0;
    }
    return result;    
}
</code></pre>

<h3>查找最长回文子串</h3>

<p>有了上面的例子返回最长子串就比较简单了，只要有个char *保存最长的子串然后返回就可以了。</p>

<pre><code class="c">char* findPalindromicString(char *s){
    char *sp=s,*ep=s+1;
    char *tmpSp,*tmpEp;
    char *startPoint=s;
    bool isPalindromic=true;
    int max =1;
    int tmpLength =0;
    char *result;
    int index;
    if(!(*sp)){
        return "";
    }
    while (*sp)
    {
        while(*ep){
            for(tmpSp=sp,tmpEp=ep;tmpSp&lt;tmpEp;tmpSp++,tmpEp--){
                if(*tmpSp != *tmpEp){
                    isPalindromic = false;
                    break;
                }
            }
            if(isPalindromic){
                tmpLength = ep - sp + 1;
                if(tmpLength &gt; max){
                    max = tmpLength;
                    startPoint = sp;
                }
            }
            isPalindromic = true;
            ep++;
        }
        sp++;
        ep = sp + 1;
        isPalindromic = true;
        tmpLength = 0;
    }
    result = (char*)malloc(sizeof(char)*(max+1));
    for(index=0;index&lt;max;index++){
        result[index]=*(startPoint++); 
    }
    result[max]='\0';
    return result;    
}
</code></pre>

<h2>运行结果</h2>

<p>下面为在leetcode的运行结果</p>

<pre><code class="c">Runtime: 1644 ms, faster than 5.05% of C online submissions for Longest Palindromic Substring.
Memory Usage: 7.3 MB, less than 18.18% of C online submissions for Longest Palindromic Substring.
</code></pre>

<p><strong>效果很差</strong></p>

<h2>代码优化</h2>

<h3>时间复杂度优化</h3>

<p>从上面的代码中可以看到查找回文字符串的时间复杂度至少为O(n<sup>2</sup>),这个时间主要花在了字符串的遍历上面。一共有这么多的遍历：</p>

<pre><code class="c">n(n-1)+(n-1)(n-2)+...+2*1
</code></pre>

<p>为了找到所有可能的回文子串，遍历了所有的子串，通过检查子串来确定是否是回文的。</p>

<p>思考：是否可以不检查所有的字符串就能找到回文字符串？</p>

<p>回文字符串是对称的，对称的一个重要特点是从中间开始两边的字符串相等。如果按照这个思路来解决的话我们就可以很快的判断一个子串是不是回文的，而且不用检查所有的字符串。</p>

<p>举个例子：</p>

<pre><code class="c">查找abcbd字符串的最长回文
</code></pre>

<p>按照以前的思路我们需要检查的子串如下：</p>

<pre><code class="c">ab
abc
abcb
abcbd
bc
bcb //回文子串
bcbd
cb
cbd
bd
</code></pre>

<p>如果按照新的思路来考虑需要检查下面的子串：</p>

<pre><code class="c">abc
bcb//回文子串
cbd
</code></pre>

<p>从两个思路需要检查的子串数量可以看出优化后方法的时间复杂度会下降很多。</p>

<p>新思路代码：</p>

<pre><code class="c">char * findPalindromicStringOpti1(char *s){
    char *sp = s,*lower,*upper,*startPoint=s;
    int maxLength=1,tmpLength=1,index=0;
    char * result;
    bool odd=false;
    if(!(*s)||!(*(s+1))){
        return s;
    }
    if(!*(sp+2)){
        if(*(sp)==*(sp+1)){
            maxLength = 2;
            startPoint = s;
        }
    }else{
        for(sp=sp+1;*(sp+1);sp++){
            lower = sp - 1;
            upper = sp + 1;
            for(;lower&gt;=s&amp;&amp;*upper&amp;&amp;*lower==*upper;lower--,upper++);
            tmpLength = upper - lower - 1;
            if(tmpLength &gt; maxLength){
                maxLength = tmpLength;
                startPoint = ++lower;
            }
            lower = sp;
            upper = sp+1;
            if(*(sp-1)==*sp){
                lower = sp-1;
                upper =sp;
            }
            if(*(sp+1)==*sp){
                upper = sp+1;
                lower = sp;
            }
            for(;lower&gt;=s&amp;&amp;*upper&amp;&amp;*lower==*upper;lower--,upper++);
            tmpLength = upper - lower - 1;
            if(tmpLength &gt; maxLength){
                maxLength = tmpLength;
                startPoint = ++lower;
            }
        }
    }
    result = (char*)malloc(sizeof(char)*(maxLength+1));
    for(index=0;index&lt;maxLength;index++){
        result[index]=*(startPoint++); 
    }
    result[maxLength]='\0';
    return result; 

}
</code></pre>

<p>优化后的运行结果</p>

<pre><code class="c">Runtime: 12 ms, faster than 86.53% of C online submissions for Longest Palindromic Substring.
Memory Usage: 7.1 MB, less than 90.91% of C online submissions for Longest Palindromic Substring.
</code></pre>

<p><strong>优化后无论是时间还是内存都有了很大的提升</strong></p>

<p>有上可以看出来时间和空间复杂度在换个思路解题后都有了很大的提升。时间和空间的矛盾只有在其中一方已经优化到很好的时候才会体现。</p>

<h3>空间复杂度优化</h3>

<p>同上</p>

<h3>别人的思路</h3>

<h4>动态规划</h4>

<p>字符串的长度为N</p>

<p>i，j均小于N</p>

<p>P(i,j)为下标从i到j的子串</p>

<p>如果P(i,j)为回文子串，则P(i+1,j-1)也是回文的。</p>

<p>反向可以得出如果一个子串是回文的那么它的子串也一定是回文的，即：</p>

<pre><code class="c">P(i,j) = P(i+1,j-1)&amp;&amp;S[i]==S[j]
</code></pre>

<p>实现代码如下：</p>

<pre><code class="c">char * findPalindromicStringOptiDp(char *s){
    int sLength = strlen(s);
    int **store,index=0,maxLength=1,i=0,j=0;
    char *startPoint=s,*result;
    if(!(*s)||!(*(s+1))){
        return s;
    }
    store = (int **)malloc(sizeof(int *)*sLength);
    for(index=0;index&lt;sLength;index++){
        store[index] = (int*)malloc(sizeof(int)*sLength);
        for(i=0;i&lt;sLength;i++){
            store[index][i] = 0;
        }
    }
    for(i=0;i&lt;sLength;i++){
        for(j=0;j&lt;=i;j++){
            if(i-j&lt;2){
                store[j][i] = s[j]==s[i]?1:0;
            }else{
                store[j][i]= (store[j+1][i-1]&amp;&amp;(s[j]==s[i]))?1:0;
            }
            if(store[j][i]&amp;&amp;(i-j+1)&gt;maxLength){
                startPoint = s+j;
                maxLength = i-j+1;
            }
        }
    }
    result = (char*)malloc(sizeof(char)*(maxLength+1));
    for(index=0;index&lt;maxLength;index++){
        result[index]=*(startPoint++); 
    }
    result[maxLength]='\0';
    free(store);
    return result; 
}
</code></pre>

<p>运行结果如下：</p>

<pre><code class="c">Runtime: 224 ms, faster than 13.32% of C online submissions for Longest Palindromic Substring.
Memory Usage: 183.1 MB, less than 9.09% of C online submissions for Longest Palindromic Substring.
</code></pre>

<p>由运行结果可以看到，代码使用了大量的空间运行来保存所有子串是否是回文的状态(此处可以优化，比如使用位图来表示)。运行时间也要比简单粗暴检索字符串的方式短很多。</p>

<h2>后记</h2>

<h3>需要考虑的corner case</h3>

<pre><code class="c">""
"a"
"bbb"
"bb"
"ccb"
"ac"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Two Numbers]]></title>
    <link href="http://crazyzfk.github.io/blog/2019/04/08/add-two-numbers/"/>
    <updated>2019-04-08T22:43:39+08:00</updated>
    <id>http://crazyzfk.github.io/blog/2019/04/08/add-two-numbers</id>
    <content type="html"><![CDATA[<h3>我的代码</h3>

<h4>代码一</h4>

<pre><code class="c">void add(int *value,int *step){
    if(*value&gt;=10){
        *step=*value/10;
        *value%=10;
    }else
    {
        *step=0;
    }

}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    int step=0,tmpValue;
    struct ListNode *result=NULL;
    struct ListNode *current=NULL;
    struct ListNode *pre=NULL;
    for(;l1!=NULL&amp;&amp;l2!=NULL;l1=l1-&gt;next,l2=l2-&gt;next){
        tmpValue=l1-&gt;val+l2-&gt;val+step;
        add(&amp;tmpValue,&amp;step);
        current=(struct ListNode*)malloc(sizeof(struct ListNode));

        current-&gt;val=tmpValue;
        if(!pre&amp;&amp;!result){
            result=current;
            pre=current;
        }else
        {
            pre-&gt;next=current;
            pre=current;
        }
    }
    if(l1){
        for(;l1;l1=l1-&gt;next){
            current=(struct ListNode*)malloc(sizeof(struct ListNode));
            tmpValue=l1-&gt;val+step;
            add(&amp;tmpValue,&amp;step);
            current-&gt;val=tmpValue;
            pre-&gt;next=current;
            pre=current;
        }
    }
    if(l2){
        for(;l2;l2=l2-&gt;next){
            current=(struct ListNode*)malloc(sizeof(struct ListNode));
            tmpValue=l2-&gt;val+step;
            add(&amp;tmpValue,&amp;step);
            current-&gt;val=tmpValue;
            pre-&gt;next=current;
            pre=current;
        }
    }
    if(step&gt;0){
        current=(struct ListNode*)malloc(sizeof(struct ListNode));
        current-&gt;val=step;
        pre-&gt;next=current;
        pre=current;
    }
    current-&gt;next=NULL;
    return result;
}
</code></pre>

<h4>运行结果</h4>

<pre><code>Runtime: 32 ms
Memory Usage: 17.9 MB
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Substring Without Repeating Characters]]></title>
    <link href="http://crazyzfk.github.io/blog/2019/04/03/Longest-Substring-Without-Repeating-Characters/"/>
    <updated>2019-04-03T20:00:00+08:00</updated>
    <id>http://crazyzfk.github.io/blog/2019/04/03/Longest-Substring-Without-Repeating-Characters</id>
    <content type="html"><![CDATA[<h3>我的代码</h3>

<h4>代码一</h4>

<pre><code class="c">int lengthOfLongestSubstring(char* s) {
    char *sp;
    int array[128]={0};
    int i,j,len,max;
    sp=s;
    len=0;
    max=0;
    while(*sp){
        i=*sp;
        if(array[i]==0){
            len++;
            array[i]=len;
            sp++;
        }else{
            sp-=len-array[i];
            if(len&gt;max){
                max=len;
            }
            len=0;
            for(j=0;j&lt;128;j++){
                array[j]=0;
            }
        } 
    }
    if(len&gt;max){
        max=len;
    }
    return max;

}
</code></pre>

<h3>运行结果</h3>

<pre><code>Runtime: 28 ms, faster than 38.82% of C online submissions for Longest Substring Without Repeating Characters.
Memory Usage: 7.1 MB, less than 100.00% of C online submissions for Longest Substring Without Repeating Characters
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum，three Sum]]></title>
    <link href="http://crazyzfk.github.io/blog/2019/03/09/two-sum/"/>
    <updated>2019-03-09T17:00:00+08:00</updated>
    <id>http://crazyzfk.github.io/blog/2019/03/09/two-sum</id>
    <content type="html"><![CDATA[<h3>我的代码</h3>

<h4>代码一</h4>

<pre><code class="C">int* twoSum(int* nums, int numsSize, int target) {
    int i;
    int j;
    int temp;
    int *values=(int *)malloc(2*sizeof(int));
    for(i=0;i&lt;numsSize;i++){
        temp=nums[i];
        for(j=i;j&lt;numsSize;j++){
            if(target-temp==nums[j]){
                values[0]=i;
                values[1]=j;
            }
        }
    }
    return values;
}
</code></pre>

<h5>测试结果</h5>

<pre><code>Wrong Answer
Details 
Input
[3,3]
6
Output
[1,1]
Expected
[0,1]
</code></pre>

<h5>分析</h5>

<p>j的初始值应当比i大才能获取的是数组中的两个。</p>

<h4>代码二</h4>

<pre><code>int* twoSum(int* nums, int numsSize, int target) {
    int i;
    int j;
    int temp;
    int foundflag=0;
    int *values=(int *)malloc(2*sizeof(int));
    for(i=0;i&lt;numsSize;i++){
        temp=nums[i];
        for(j=i+1;j&lt;numsSize;j++){
            if(target-temp==nums[j]){
                values[0]=i;
                values[1]=j;
                foundflag=1
                break;
            }
        }
        if(floudflag==1){
            break;
        }
    }
    return values;
}
</code></pre>

<h5>测试结果</h5>

<p>Details
Runtime: 128 ms, faster than 42.13% of C online submissions for Two Sum.
Memory Usage: 7.6 MB, less than 65.55% of C online submissions for Two Sum.</p>

<h3>总结</h3>

<p>没有把握好细节部分的处理</p>

<h3>threesum</h3>

<h4>代码一</h4>

<pre><code class="C">int * sort(int *nums,int size){
    int i=0;
    int j=0;
    int tmp;
    int *result=(int*)malloc(size*sizeof(int *));
    for(i=0;i&lt;size;i++){
        result[i]=nums[i];
    }
    for(i=0;i&lt;size-1;i++){
        for(j=0;j&lt;size-i-1;j++){
            if(result[j]&gt;result[j+1]){
                tmp=result[j];
                result[j]=result[j+1];
                result[j+1]=tmp;
            }
        }
    }
    return result;
}
int** threeSum(int* nums, int numsSize, int* returnSize) {
    int i;
    int j;
    int k;
    int l;
    int m;
    int flag=0;
    int search;
    int equal;
    int uniq=0;
    int * in_result,*new_one;
    int **result=(int **)malloc(0);
    for(i=0;i&lt;numsSize;i++){
        for(j=i+1;j&lt;numsSize;j++){
            for(k=j+1;k&lt;numsSize;k++){
                if(nums[i]+nums[j]+nums[k]==0){
                    int *value=(int*)malloc(3*sizeof(int));
                    value[0]=nums[i];
                    value[1]=nums[j];
                    value[2]=nums[k];
                    equal=0;
                    uniq=0;
                    new_one=sort(value,3);
                    for(search=0;search&lt;flag;search++){
                        in_result=sort(result[search],3);
                        for(l=0;l&lt;3;l++){
                            if(in_result[l]!=new_one[l]){
                                break;
                            }
                        }
                        if(l==3){
                            uniq=1;
                            break;
                        }
                        free(in_result);
                    }
                    if(uniq==1){
                        break;
                    }
                    flag++;
                    result=(int**)realloc(result,flag*sizeof(int*));
                    result[flag-1]=value;
                    free(new_one);
                }
            }

        }
    }
    *returnSize=flag;
    return result;
}
</code></pre>

<h4>测试结果</h4>

<p>Time Limit Exceeded</p>

<h4>代码二</h4>

<pre><code class="c">struct Node{
    int a;
    int b;
    int c;
    struct Node *next;
};
void sort(int *list,int size){
    int i,j,tmp,k;
    for(i=0;i&lt;size-1;i++){
        for(j=0;j&lt;size-i-1;j++){
            if(list[j]&gt;list[j+1]){
                tmp=list[j];
                list[j]=list[j+1];
                list[j+1]=tmp;
            }
        }
    }
}
int** threeSum(int* nums, int numsSize, int* returnSize){
    int i,left,right,sum;
    int **result=NULL;
    struct Node *head=NULL;
    struct Node *curr=NULL;
    struct Node *pre=NULL;
    int *value;
    sort(nums,numsSize);
    for(i=0;i&lt;numsSize-1;i++){
        if(i&gt;0&amp;&amp;nums[i]==nums[i-1]){
            continue;
        }
        left=i+1;
        right=numsSize-1;
        while(left&lt;right){
            sum=nums[i]+nums[left]+nums[right];
            if(sum==0){
                (*returnSize)++;
                if(!head){
                    head=(struct Node*)malloc(sizeof(struct Node));
                    curr=head;
                }else{
                    curr=(struct Node*)malloc(sizeof(struct Node));
                }
                curr-&gt;a=nums[i];
                curr-&gt;b=nums[left];
                curr-&gt;c=nums[right];
                curr-&gt;next=NULL;
                if(pre){
                    pre-&gt;next=curr;
                }
                pre=curr;

                while(left&lt;right&amp;&amp;nums[left]==nums[left+1]){
                    left++;
                }
                while(left&lt;right&amp;&amp;nums[right]==nums[right-1]){
                    right--;
                }
                left++;
                right--;
            }else if(sum&lt;0){
                left++;
            }else{
                right--;
            }

        }
    }
    result=(int **)malloc((*returnSize)*sizeof(int*));
    i=0;
    while(head){
        value=(int *)malloc(sizeof(int)*3);
        value[0]=head-&gt;a;
        value[1]=head-&gt;b;
        value[2]=head-&gt;c;
        result[i++]=value;
        curr=head;
        head=head-&gt;next;
        free(curr);
    }
    return result;
}
</code></pre>

<h4>运行结果</h4>

<pre><code>Runtime: 168 ms
Memory Usage: 24.5 MB
</code></pre>
]]></content>
  </entry>
  
</feed>
